--190. SQL로 머신러닝 구현하기 12 (SUPPORT VECTOR MACHINE) 

/*
유방에 있는 종양의 크기와 모양 등의 데이터를 학습하여 종양이 악성인지 양성인지 예측
서포트백터 머신(support vector machine) 알고리즘으로 구현
*/

--1. 유방암 데이터를 저장할 테이블을 생성
DROP TABLE WISC_BC_DATA;

CREATE TABLE WISC_BC_DATA
( ID	                 NUMBER(10),
DIAGNOSIS	         VARCHAR2(5), 
RADIUS_MEAN	         NUMBER(20,7),
TEXTURE_MEAN	         NUMBER(20,7),
PERIMETER_MEAN	         NUMBER(20,7),
AREA_MEAN	         NUMBER(20,7),
SMOOTHNESS_MEAN      NUMBER(20,7),
COMPACTNESS_MEAN     NUMBER(20,7),
CONCAVITY_MEAN	         NUMBER(20,7),
POINTS_MEAN	         NUMBER(20,7),
SYMMETRY_MEAN	         NUMBER(20,7),
DIMENSION_MEAN	         NUMBER(20,7),
RADIUS_SE	         NUMBER(20,7),
TEXTURE_SE	         NUMBER(20,7),
PERIMETER_SE	         NUMBER(20,7),
AREA_SE	                      NUMBER(20,7),
SMOOTHNESS_SE	         NUMBER(20,7),
COMPACTNESS_SE	         NUMBER(20,7),
CONCAVITY_SE	         NUMBER(20,7),
POINTS_SE	         NUMBER(20,7),
SYMMETRY_SE	         NUMBER(20,7),
DIMENSION_SE	         NUMBER(20,7),
RADIUS_WORST	         NUMBER(20,7),
TEXTURE_WORST	         NUMBER(20,7),
PERIMETER_WORST	         NUMBER(20,7),
AREA_WORST	         NUMBER(20,7),
SMOOTHNESS_WORST	 NUMBER(20,7),
COMPACTNESS_WORST	 NUMBER(20,7),
CONCAVITY_WORST            NUMBER(20,7),
POINTS_WORST	         NUMBER(20,7),
SYMMETRY_WORST	         NUMBER(20,7),
DIMENSION_WORST          NUMBER(20,7) );

--데이터 입력: SQL Developer를 이용해서 wisc_bc_data.csv 를 WISC_BC_DATA 테이블에 입력

SELECT COUNT(*) FROM WISC_BC_DATA;
-- 569

-- 2. 유방암 데이터를 훈련데이터와 테스트 데이터로 분리
DROP TABLE WISC_BC_DATA_TRAINING;

CREATE TABLE WISC_BC_DATA_TRAINING
AS
SELECT *
   FROM WISC_BC_DATA 
   WHERE ROWNUM < 501;

DROP TABLE WISC_BC_DATA_TEST; 

CREATE TABLE WISC_BC_DATA_TEST
AS
SELECT *
  FROM WISC_BC_DATA
MINUS
SELECT *
  FROM WISC_BC_DATA_TRAINING;

-- 3. 머신러닝 모델 구성정보 테이블을 생성
DROP TABLE DTSETTINGS;

CREATE TABLE DTSETTINGS
AS
SELECT *
  FROM TABLE (DBMS_DATA_MINING.GET_DEFAULT_SETTINGS)
   WHERE SETTING_NAME LIKE '%GLM%';

BEGIN

   INSERT INTO DTSETTINGS
     VALUES (DBMS_DATA_MINING.ALGO_NAME, 'ALGO_SUPPORT_VECTOR_MACHINES');

   INSERT INTO DTSETTINGS
     VALUES (DBMS_DATA_MINING.PREP_AUTO, 'ON');

   INSERT INTO DTSETTINGS
     VALUES (DBMS_DATA_MINING.SVMS_KERNEL_FUNCTION, 'SVMS_GAUSSIAN');

   COMMIT;
END;
/

-- 4. 서포트 백터 머신(support vector machine) 모델을 생성
BEGIN
  DBMS_DATA_MINING.DROP_MODEL('WC_MODEL');
END;
/

BEGIN
   DBMS_DATA_MINING.CREATE_MODEL (
      MODEL_NAME            => 'WC_MODEL',
      MINING_FUNCTION       => DBMS_DATA_MINING.CLASSIFICATION,
      DATA_TABLE_NAME       => 'WISC_BC_DATA_TRAINING',
      CASE_ID_COLUMN_NAME   => 'ID',
      TARGET_COLUMN_NAME    => 'DIAGNOSIS',
      SETTINGS_TABLE_NAME   => 'DTSETTINGS');
END;
/

-- 5. 머신러닝 모델을 확인
SELECT MODEL_NAME,
          ALGORITHM,
          MINING_FUNCTION
  FROM ALL_MINING_MODELS
 WHERE MODEL_NAME = 'WC_MODEL';

-- 6. 머신러닝 모델의 구성정보를 확인
SELECT SETTING_NAME, SETTING_VALUE
  FROM ALL_MINING_MODEL_SETTINGS
  WHERE MODEL_NAME = 'WC_MODEL';

-- 7. 서포트 백터 머신러닝 모델의 성능정보를 확인
DROP TABLE WC_DATA_TEST_MATRIX;
      
CREATE OR REPLACE VIEW VIEW_WISC_BC_DATA_TEST
AS
SELECT ID, DIAGNOSIS, 
          PREDICTION(WC_MODEL USING *) PREDICTED_VALUE,
          PREDICTION_PROBABILITY(WC_MODEL USING * ) PROBABILITY
 FROM WISC_BC_DATA_TEST;

-- 8. 모델이 테스트 데이터를 악성으로 예측했는지 양성으로 예측했는지 확인
SELECT ID 환자번호, DIAGNOSIS 실제값, PREDICTED_VALUE 예측값, PROBABILITY 예측확률
  FROM VIEW_WISC_BC_DATA_TEST
  WHERE  id in (87930, 91858, 92751, 842517, 845636);

-- 9. 서포트 벡터 머신 모델의 성능을 확인
SET  SERVEROUTPUT ON

DECLARE
   V_ACCURACY NUMBER;
BEGIN
   DBMS_DATA_MINING.COMPUTE_CONFUSION_MATRIX (
      ACCURACY => V_ACCURACY,
      APPLY_RESULT_TABLE_NAME => 'VIEW_WISC_BC_DATA_TEST',
      TARGET_TABLE_NAME => 'WISC_BC_DATA_TEST',
      CASE_ID_COLUMN_NAME => 'ID',
      TARGET_COLUMN_NAME => 'DIAGNOSIS',
      CONFUSION_MATRIX_TABLE_NAME => 'WC_DATA_TEST_MATRIX',
      SCORE_COLUMN_NAME => 'PREDICTED_VALUE',
      SCORE_CRITERION_COLUMN_NAME => 'PROBABILITY',
      COST_MATRIX_TABLE_NAME => NULL,
      APPLY_RESULT_SCHEMA_NAME => NULL,
      TARGET_SCHEMA_NAME => NULL,
      COST_MATRIX_SCHEMA_NAME => NULL,
      SCORE_CRITERION_TYPE => 'PROBABILITY');
   DBMS_OUTPUT.PUT_LINE('**** MODEL ACCURACY ****: ' || ROUND(V_ACCURACY,4));
END;
/


--191. SQL로 머신러닝 구현하기 13 (SUPPORT VECTOR MACHINE)
/*
유방암의 종양이 악성인지 양성인지를 예측하는 서포트 백터 머신러닝 모델의 커널(엔진)을 변경
*/
-- 1. 예제191번에서 생성한 서포트 벡터 머신러닝 모델 구성 정보를 재구성
DROP TABLE DTSETTINGS;

CREATE TABLE DTSETTINGS
( SETTING_NAME    VARCHAR2 (200),
 SETTING_VALUE   VARCHAR2 (200) );

BEGIN

   INSERT INTO DTSETTINGS
     VALUES (DBMS_DATA_MINING.ALGO_NAME, 'ALGO_SUPPORT_VECTOR_MACHINES');

   INSERT INTO DTSETTINGS
      VALUES (DBMS_DATA_MINING.PREP_AUTO, 'ON');

   INSERT INTO DTSETTINGS
     VALUES (DBMS_DATA_MINING.SVMS_KERNEL_FUNCTION, 'SVMS_LINEAR');

COMMIT;
END;
/

-- 2. 모델 생성을 생성
BEGIN
  DBMS_DATA_MINING.DROP_MODEL('WC_MODEL');
END;
/

BEGIN
   DBMS_DATA_MINING.CREATE_MODEL (
      MODEL_NAME            => 'WC_MODEL',
      MINING_FUNCTION       => DBMS_DATA_MINING.CLASSIFICATION,
      DATA_TABLE_NAME       => 'WISC_BC_DATA_TRAINING',
      CASE_ID_COLUMN_NAME   => 'ID',
      TARGET_COLUMN_NAME    => 'DIAGNOSIS',
      SETTINGS_TABLE_NAME   => 'DTSETTINGS');
END;
/

-- 3. 생성된 모델을 확인
SELECT MODEL_NAME,
          ALGORITHM,
          MINING_FUNCTION
  FROM ALL_MINING_MODELS
  WHERE MODEL_NAME = 'WC_MODEL';

-- 4. 생성된 모델의 구성정보를 확인
SELECT SETTING_NAME, SETTING_VALUE
  FROM ALL_MINING_MODEL_SETTINGS
  WHERE MODEL_NAME = 'WC_MODEL';

-- 5. 생성한 머신러닝 모델의 성능을 확인
DROP TABLE WC_DATA_TEST_MATRIX;
      
CREATE OR REPLACE VIEW   VIEW_WISC_BC_DATA_TEST
AS
SELECT ID, PREDICTION(WC_MODEL USING *) PREDICTED_VALUE,
          PREDICTION_PROBABILITY(WC_MODEL USING * ) PROBABILITY
  FROM WISC_BC_DATA_TEST;
  
set serveroutput on  
  
DECLARE
   V_ACCURACY NUMBER;
BEGIN
   DBMS_DATA_MINING.COMPUTE_CONFUSION_MATRIX (
      ACCURACY           => V_ACCURACY,
      APPLY_RESULT_TABLE_NAME => 'VIEW_WISC_BC_DATA_TEST',
      TARGET_TABLE_NAME       => 'WISC_BC_DATA_TEST',
      CASE_ID_COLUMN_NAME   => 'ID',
      TARGET_COLUMN_NAME   => 'DIAGNOSIS',
      CONFUSION_MATRIX_TABLE_NAME => 'WC_DATA_TEST_MATRIX',
      SCORE_COLUMN_NAME       => 'PREDICTED_VALUE',
      SCORE_CRITERION_COLUMN_NAME => 'PROBABILITY',
      COST_MATRIX_TABLE_NAME      => NULL,
      APPLY_RESULT_SCHEMA_NAME   => NULL,
      TARGET_SCHEMA_NAME       => NULL,
      COST_MATRIX_SCHEMA_NAME => NULL,
      SCORE_CRITERION_TYPE   => 'PROBABILITY');
   DBMS_OUTPUT.PUT_LINE('**** MODEL ACCURACY ****: ' || ROUND(V_ACCURACY,4));
END;
/


--192. SQL로 머신러닝 구현하기 14 (SUPPORT VECTOR MACHINE) 
/*
191번에서 생성한 유방암 환자 여부를 예측하는 서포트 벡터 머신러닝 모델을 활용하는 PL/SQL 프로그래밍 생성
*/

SET SERVEROUTPUT ON
SET VERIFY OFF

ACCEPT P_ID PROMPT '환자 번호를 입력하세요~ (예: 845636)'

DECLARE  
   V_PRED    VARCHAR2(20);
   V_PROB    NUMBER(10,2);

BEGIN

SELECT PREDICTION (WC_MODEL USING *),
          PREDICTION_PROBABILITY(WC_MODEL  USING * )  INTO V_PRED, V_PROB
  FROM WISC_BC_DATA_TEST
  WHERE ID = '&P_ID';

 IF V_PRED ='M' THEN 

   DBMS_OUTPUT.PUT_LINE('머신러닝이 예측한 결과: 유방암 환자입니다. 유방암일 확률은 ' || ROUND(V_PROB,2) * 100 || '%입니다');

 ELSE 
    DBMS_OUTPUT.PUT_LINE('머신러닝이 예측한 결과: 유방암 환자가 아닙니다. 유방암 환자가 아닐 확률은 ' || ROUND(V_PROB,2) * 100 || '%입니다');

 END IF;

END;
/


--193 SQL로 머신러닝 구현하기 15 (REGRESSION)

/*
학과 점수, 체육 점수, 음악 점수 세 가지 중에서 어느 과목이 학교 입학에 영향을 주는 과목인지 회귀분석 통해
알아봄
STUDENT_SCORE 테이블의 데이터에서 ST_ID는 식별자 컬럼
ACADEMIC(학과 점수), SPORT(체육 점수), MUSIC(음악 점수)는 독립변수
ACCEPTANCE(입학 기준 점수)는 종속 변수
*/

-- 1.  학생점수 테이블을 생성
DROP TABLE STUDENT_SCORE;

CREATE TABLE STUDENT_SCORE
(  ST_ID        NUMBER(10),
  ACADEMIC   NUMBER(20,8),
  SPORTS      NUMBER(30,10),
  MUSIC       NUMBER(30,10),
 ACCEPTANCE  NUMBER(30,10) );
-- 데이터 입력: SQL Developer를 이용해서 student_score.csv 를 STUDENT_SCORE 테이블에 입력

select count(*) from STUDENT_SCORE;
-- 200 

-- 2. 훈련 데이터와 테스트 데이터로 분리
DROP TABLE STUDENT_SCORE_TRAINING; 

CREATE TABLE STUDENT_SCORE_TRAINING
AS
   SELECT *
     FROM STUDENT_SCORE
     WHERE ST_ID < 181;

DROP TABLE STUDENT_SCORE_TEST;

CREATE TABLE STUDENT_SCORE_TEST
AS
   SELECT *
     FROM STUDENT_SCORE
     WHERE ST_ID >= 181;

-- 3. 회귀 분석을 위한 머신러닝 모델 구성 테이블을 생성
DROP TABLE SETTINGS_REG1;

CREATE TABLE SETTINGS_REG1
AS
SELECT *
     FROM TABLE (DBMS_DATA_MINING.GET_DEFAULT_SETTINGS)
     WHERE SETTING_NAME LIKE '%GLM%';

BEGIN

INSERT INTO SETTINGS_REG1
  VALUES (DBMS_DATA_MINING.ALGO_NAME, 'ALGO_GENERALIZED_LINEAR_MODEL');

INSERT INTO SETTINGS_REG1
  VALUES (DBMS_DATA_MINING.PREP_SCALE_2DNUM, 'PREP_SCALE_RANGE');

COMMIT;

END;
/

-- 4.  회귀 모델을 생성
BEGIN
 DBMS_DATA_MINING.DROP_MODEL('MD_REG_MODEL1');
END;
/

BEGIN 
   DBMS_DATA_MINING.CREATE_MODEL(
      MODEL_NAME            => 'MD_REG_MODEL1',
      MINING_FUNCTION       => DBMS_DATA_MINING.REGRESSION,
      DATA_TABLE_NAME       => 'STUDENT_SCORE_TRAINING',
      CASE_ID_COLUMN_NAME   => 'ST_ID',
      TARGET_COLUMN_NAME    => 'ACCEPTANCE',
      SETTINGS_TABLE_NAME   => 'SETTINGS_REG1');
END;
/

-- 5. 모델 생성 여부를 확인
SELECT MODEL_NAME,
          ALGORITHM,
          MINING_FUNCTION
  FROM ALL_MINING_MODELS
  WHERE MODEL_NAME = 'MD_REG_MODEL1';

-- 6. 모델 구성 정보를 확인
SELECT SETTING_NAME, SETTING_VALUE
  FROM ALL_MINING_MODEL_SETTINGS
  WHERE MODEL_NAME = 'MD_REG_MODEL1';

-- 7. 테스트 데이터에 대해 회귀분석 모델이 예측한 예측점수를 확인
SELECT ST_ID 학생번호, ACADEMIC 학과점수, ROUND(MUSIC,2) 음악점수 , 
          SPORTS 체육점수, ROUND(ACCEPTANCE,2) AS 실제점수, ROUND(MODEL_PREDICT_RESPONSE,2) AS 예측점수
 FROM ( 
           SELECT T.*, PREDICTION (MD_REG_MODEL1 USING *) MODEL_PREDICT_RESPONSE
             FROM STUDENT_SCORE_TEST T
      );

-- 8. 회귀 모델의 결정계수 R 스퀘어 값을 확인
SELECT *
  FROM TABLE(DBMS_DATA_MINING.GET_MODEL_DETAILS_GLOBAL(MODEL_NAME =>  'MD_REG_MODEL1'))
  WHERE GLOBAL_DETAIL_NAME IN ('R_SQ','ADJUSTED_R_SQUARE');

-- 9. 입학점수에 영향력 있는 변수가 무엇인지 확인합니다. 
SELECT ATTRIBUTE_NAME, COEFFICIENT
  FROM TABLE (DBMS_DATA_MINING.GET_MODEL_DETAILS_GLM ('MD_REG_MODEL1'));


--194. SQL로 머신러닝 구현하기 16 (REGRESSION)

--미국 국민들의 의료비 지출에 영향력을 크게 미치는 요소가 무엇인지 회귀분석으로 알아보기
-- 1. 의료비 데이터 테이블을 생성
DROP TABLE INSURANCE;

CREATE TABLE INSURANCE
( ID         NUMBER(10),
  AGE       NUMBER(3),
  SEX        VARCHAR2(10),
  BMI        NUMBER(10,2),
  CHILDREN  NUMBER(2),
  SMOKER    VARCHAR2(10),
  REGION    VARCHAR2(20), 
  EXPENSES  NUMBER(10,2) );
-- 데이터 입력: SQL Developer를 이용해서 insurance.csv 를 insurance 테이블에 입력
  
select count(*) from INSURANCE;
-- 1338
  
-- 2. 훈련 데이터와 테스트 데이터로 분리
DROP TABLE INSURANCE_TRAINING; 

CREATE TABLE INSURANCE_TRAINING
AS
   SELECT *
     FROM INSURANCE
     WHERE ID < 1114;

DROP TABLE INSURANCE_TEST;

CREATE TABLE INSURANCE_TEST
AS
   SELECT *
     FROM INSURANCE
     WHERE ID >= 1114;

-- 3. 머신러닝 모델의 환경 구성 테이블을 생성
DROP TABLE SETTINGS_REG2;

CREATE TABLE SETTINGS_REG2
AS
SELECT *
  FROM TABLE (DBMS_DATA_MINING.GET_DEFAULT_SETTINGS)
  WHERE SETTING_NAME LIKE '%GLM%';

BEGIN

INSERT INTO SETTINGS_REG2
 VALUES (DBMS_DATA_MINING.ALGO_NAME,'ALGO_GENERALIZED_LINEAR_MODEL');

INSERT INTO SETTINGS_REG2
 VALUES (DBMS_DATA_MINING.PREP_AUTO, 'ON');

COMMIT;

END;
/

-- 4. 머신러닝 모델을 생성
BEGIN
  DBMS_DATA_MINING.DROP_MODEL('MD_REG_MODEL2');
END;
/

BEGIN 

   DBMS_DATA_MINING.CREATE_MODEL(
      MODEL_NAME            => 'MD_REG_MODEL2',
      MINING_FUNCTION       => DBMS_DATA_MINING.REGRESSION,
      DATA_TABLE_NAME       => 'INSURANCE_TRAINING',
      CASE_ID_COLUMN_NAME   => 'ID',
      TARGET_COLUMN_NAME    => 'EXPENSES',
      SETTINGS_TABLE_NAME   => 'SETTINGS_REG2');
END;
/

-- 5. 생성된 머신러닝 모델을 확인
SELECT MODEL_NAME,
          ALGORITHM,
          MINING_FUNCTION
  FROM ALL_MINING_MODELS
  WHERE MODEL_NAME = 'MD_REG_MODEL2';

-- 6. 머신러닝 모델 구성 정보를 확인
SELECT SETTING_NAME, SETTING_VALUE
  FROM ALL_MINING_MODEL_SETTINGS
  WHERE MODEL_NAME = 'MD_REG_MODEL2';

-- 7. 회귀분석 모델의 회귀계수를 확인
SELECT ATTRIBUTE_NAME, ATTRIBUTE_VALUE, ROUND(COEFFICIENT)
  FROM TABLE (DBMS_DATA_MINING.GET_MODEL_DETAILS_GLM ('MD_REG_MODEL2'));

-- 8. 예측 값을 확인
SELECT ID, AGE, SEX, EXPENSES, 
          ROUND(PREDICTION (MD_REG_MODEL2 USING *),2) MODEL_PREDICT_RESPONSE
  FROM INSURANCE_TEST T;

-- 9. 결정계수 R 스퀘어 값 확인
SELECT GLOBAL_DETAIL_NAME, ROUND(GLOBAL_DETAIL_VALUE,3)
  FROM
  TABLE(DBMS_DATA_MINING.GET_MODEL_DETAILS_GLOBAL(MODEL_NAME =>'MD_REG_MODEL2'))
  WHERE  GLOBAL_DETAIL_NAME IN ('R_SQ','ADJUSTED_R_SQUARE');


--195. SQL로 머신러닝 구현하기 17 (파생변수 생성)

--비만인 사람이 흡연까지 하게 되면 의료비가 더 증가되는지 미국 국민 데이터를 회귀분석
-- 1. 학습 테이블에 파생변수 컬럼을 추가
ALTER TABLE INSURANCE
  DROP COLUMN BMI30;

ALTER TABLE INSURANCE
  ADD BMI30 NUMBER(10);

UPDATE INSURANCE   I
   SET BMI30 = ( SELECT CASE WHEN BMI >= 30 AND SMOKER='yes'
                                THEN  1  ELSE  0  END 
                        FROM INSURANCE S
                        WHERE S.ROWID = I.ROWID) ;
COMMIT;

-- 2. 훈련 데이터와 테스트 데이터를 9대 1로 분리
DROP TABLE INSURANCE_TRAINING; 

CREATE TABLE INSURANCE_TRAINING
AS
   SELECT *
     FROM INSURANCE
     WHERE ID < 1114;

DROP TABLE INSURANCE_TEST;

CREATE TABLE INSURANCE_TEST
AS
   SELECT *
     FROM INSURANCE
    WHERE ID >= 1114;

-- 3. 머신러닝 모델을 생성
BEGIN
  DBMS_DATA_MINING.DROP_MODEL('MD_REG_MODEL3');
END;
/

BEGIN 

   DBMS_DATA_MINING.CREATE_MODEL(
      MODEL_NAME            => 'MD_REG_MODEL3',
      MINING_FUNCTION       => DBMS_DATA_MINING.REGRESSION,
      DATA_TABLE_NAME       => 'INSURANCE_TRAINING',
      CASE_ID_COLUMN_NAME   => 'ID',
      TARGET_COLUMN_NAME    => 'EXPENSES',
      SETTINGS_TABLE_NAME   => 'SETTINGS_REG2');
END;
/

-- 4. 생성된 모델을 확인
SELECT MODEL_NAME,
          ALGORITHM,
          MINING_FUNCTION
  FROM ALL_MINING_MODELS
  WHERE MODEL_NAME = 'MD_REG_MODEL3';

-- 5. 회귀 모수를 확인
SELECT ATTRIBUTE_NAME, ATTRIBUTE_VALUE, ROUND(COEFFICIENT)
  FROM 
  TABLE (DBMS_DATA_MINING.GET_MODEL_DETAILS_GLM ('MD_REG_MODEL3'));

-- 6. R 스퀘어 값 확인
SELECT GLOBAL_DETAIL_NAME, ROUND(GLOBAL_DETAIL_VALUE,3)
  FROM
  TABLE(DBMS_DATA_MINING.GET_MODEL_DETAILS_GLOBAL(MODEL_NAME =>'MD_REG_MODEL3'))
  WHERE  GLOBAL_DETAIL_NAME IN ('R_SQ','ADJUSTED_R_SQUARE');


--196. SQL로 머신러닝 구현하기 18 (파생변수 생성)

--미국 국민 의료비 데이터를 회귀분석하여 나이가 들수록 의료비 증가하는지 확인
-- 1. 학습 테이블에 파생변수 컬럼을 추가 (기존 나이의 제곱값인 새로운 파생변수 추가)
ALTER TABLE INSURANCE
  DROP COLUMN AGE2;

ALTER TABLE INSURANCE
  ADD AGE2 NUMBER(10);

UPDATE INSURANCE
  SET AGE2 = AGE * AGE ;

COMMIT;

-- 2. 훈련 데이터와 테스트 데이터를 9대1로 분리
DROP TABLE INSURANCE_TRAINING; 

CREATE TABLE INSURANCE_TRAINING
AS
   SELECT *
     FROM INSURANCE
     WHERE ID < 1114;

DROP TABLE INSURANCE_TEST;

CREATE TABLE INSURANCE_TEST
AS
   SELECT *
     FROM INSURANCE
    WHERE ID >= 1114;

-- 3. 머신러닝 모델을 생성
BEGIN
  DBMS_DATA_MINING.DROP_MODEL('MD_REG_MODEL4');
END;
/

BEGIN 

   DBMS_DATA_MINING.CREATE_MODEL(
      MODEL_NAME            => 'MD_REG_MODEL4',
      MINING_FUNCTION       => DBMS_DATA_MINING.REGRESSION,
      DATA_TABLE_NAME       => 'INSURANCE_TRAINING',
      CASE_ID_COLUMN_NAME   => 'ID',
      TARGET_COLUMN_NAME    => 'EXPENSES',
      SETTINGS_TABLE_NAME   => 'SETTINGS_REG2');
END;
/

-- 4. 머신러닝 모델이 잘 생성되었는지 확인
SELECT MODEL_NAME,
          ALGORITHM,
          CREATION_DATE,
          MINING_FUNCTION
  FROM ALL_MINING_MODELS
  WHERE MODEL_NAME = 'MD_REG_MODEL4';

-- 5. 회귀 계수를 확인
SELECT ATTRIBUTE_NAME, ATTRIBUTE_VALUE, ROUND(COEFFICIENT)
  FROM 
  TABLE (DBMS_DATA_MINING.GET_MODEL_DETAILS_GLM ('MD_REG_MODEL4'));

-- 6. R 스퀘어 값을 확인
SELECT GLOBAL_DETAIL_NAME, ROUND(GLOBAL_DETAIL_VALUE,3)
  FROM TABLE (DBMS_DATA_MINING.GET_MODEL_DETAILS_GLOBAL(MODEL_NAME => 'MD_REG_MODEL4'))
  WHERE GLOBAL_DETAIL_NAME IN ('R_SQ','ADJUSTED_R_SQUARE');


--197. SQL로 머신러닝 구현하기 19 (APRIORI)

--APRIORI 알고리즘으로 마트에서 맥주를 사는 고객이 기저귀도 같이 사는지 연관성 분석
-- 1. 머신러닝 모델이 학습할 테이블을 생성
DROP TABLE MARKET_TABLE; 

CREATE TABLE MARKET_TABLE
  ( CUST_ID         NUMBER(10),
    STOCK_CODE    NUMBER(10),
    STOCK_NAME   VARCHAR2(30),
    QUANTITY      NUMBER(10),
    STOCK_PRICE   NUMBER(10,2),
    BUY_DATE      DATE  );
-- sqldeveloper 를 이용하여 market.csv 데이터를 로드

select count(*) from market_table;
-- 17
select * from market_table;

-- 2. 연관성 분석을 위한 환경 구성 테이블을 생성
DROP TABLE SETTINGS_ASSOCIATION_RULES;

CREATE TABLE SETTINGS_ASSOCIATION_RULES
AS
   SELECT *
     FROM TABLE (DBMS_DATA_MINING.GET_DEFAULT_SETTINGS)
     WHERE SETTING_NAME LIKE 'ASSO_%';

BEGIN
   UPDATE SETTINGS_ASSOCIATION_RULES
      SET SETTING_VALUE = 3
      WHERE SETTING_NAME = DBMS_DATA_MINING.ASSO_MAX_RULE_LENGTH;

   UPDATE SETTINGS_ASSOCIATION_RULES
      SET SETTING_VALUE = 0.03
      WHERE SETTING_NAME = DBMS_DATA_MINING.ASSO_MIN_SUPPORT;

    UPDATE SETTINGS_ASSOCIATION_RULES
      SET SETTING_VALUE = 0.03
      WHERE SETTING_NAME = DBMS_DATA_MINING.ASSO_MIN_CONFIDENCE;

   INSERT INTO SETTINGS_ASSOCIATION_RULES
        VALUES (DBMS_DATA_MINING.ODMS_ITEM_ID_COLUMN_NAME, 'STOCK_CODE');

   COMMIT;
END;
/

-- 3. 연관성 분석을 위한 머신러닝 모델을 생성
BEGIN
  DBMS_DATA_MINING.DROP_MODEL('MD_ASSOC_ANLYSIS');
END;
/

CREATE OR REPLACE VIEW VW_MARKET_TABLE 
AS 
SELECT CUST_ID, STOCK_CODE 
  FROM MARKET_TABLE;

BEGIN 
   DBMS_DATA_MINING.CREATE_MODEL(
      MODEL_NAME            => 'MD_ASSOC_ANLYSIS',
      MINING_FUNCTION       => DBMS_DATA_MINING.ASSOCIATION,
      DATA_TABLE_NAME       => 'VW_MARKET_TABLE',
      CASE_ID_COLUMN_NAME   => 'CUST_ID',
      TARGET_COLUMN_NAME    => NULL,
      SETTINGS_TABLE_NAME   => 'SETTINGS_ASSOCIATION_RULES');
END;
/

-- 4. 머신러닝 모델을 확인
SELECT MODEL_NAME,
          ALGORITHM,
          MINING_FUNCTION
  FROM ALL_MINING_MODELS
  WHERE MODEL_NAME = 'MD_ASSOC_ANLYSIS';

-- 5. 머신러닝 모델 구성 정보를 확인
SELECT SETTING_NAME, SETTING_VALUE
  FROM ALL_MINING_MODEL_SETTINGS
  WHERE MODEL_NAME = 'MD_ASSOC_ANLYSIS';

-- 6. 모델이 분석한 연관분석 결과를 확인
SELECT A.ATTRIBUTE_SUBNAME as ANTECEDENT,
          C.ATTRIBUTE_SUBNAME as CONSEQUENT,
          ROUND(RULE_SUPPORT,3) as SUPPORT,
          ROUND(RULE_CONFIDENCE,3) as CONFIDENCE,
          ROUND(RULE_LIFT,3) as LIFT
  FROM  TABLE(DBMS_DATA_MINING.GET_ASSOCIATION_RULES('MD_ASSOC_ANLYSIS',10)) T,
            TABLE(T.CONSEQUENT) C,
            TABLE(T.ANTECEDENT) A
  ORDER BY SUPPORT DESC,LIFT  DESC;


--198. SQL로 머신러닝 구현하기 20 (APRIORI)

/*
아프리오리 알고리즘 이용하여 온라인으로 물건 구매하는 고객들에게 구매하고자 하는 상품과 연관성이 있는
상품을 추천하는 머신러닝 모델 생성
*/
-- 1. 머신러닝 모델이 학습할 테이블을 생성
DROP TABLE ONLINE_RETAIL; 

CREATE TABLE ONLINE_RETAIL
( INVOICENO    VARCHAR2(100),
  STOCKCODE    VARCHAR2(100),
  DESCRIPTION  VARCHAR2(200),
  QUANTITY     NUMBER(10,2),
  INVOICEDATE  DATE,
  UNITPRICE    NUMBER(10,2),
  CUSTOMERID  NUMBER(10,2),
  COUNTRY     VARCHAR2(100) );
-- 데이터 입력: SQL Developer를 이용해서 Online Retail.csv 를 ONLINE_RETAIL 테이블에 입력

SELECT COUNT(*)  FROM ONLINE_RETAIL;
-- 541909 행

-- 2. 연관성 분석을 위한 머신러닝 환경을 세팅
DROP TABLE SETTINGS_ASSOCIATION_RULES2;

CREATE TABLE SETTINGS_ASSOCIATION_RULES2
AS
   SELECT *
     FROM TABLE (DBMS_DATA_MINING.GET_DEFAULT_SETTINGS)
     WHERE SETTING_NAME LIKE 'ASSO_%';

BEGIN
   UPDATE SETTINGS_ASSOCIATION_RULES2
     SET SETTING_VALUE = 3
     WHERE SETTING_NAME = DBMS_DATA_MINING.ASSO_MAX_RULE_LENGTH;

   UPDATE SETTINGS_ASSOCIATION_RULES2
      SET SETTING_VALUE = 0.03
      WHERE SETTING_NAME = DBMS_DATA_MINING.ASSO_MIN_SUPPORT;

    UPDATE SETTINGS_ASSOCIATION_RULES2
      SET SETTING_VALUE = 0.03
      WHERE SETTING_NAME = DBMS_DATA_MINING.ASSO_MIN_CONFIDENCE;

   INSERT INTO SETTINGS_ASSOCIATION_RULES2
      VALUES (DBMS_DATA_MINING.ODMS_ITEM_ID_COLUMN_NAME, ' INVOICENO');
   COMMIT;
END;
/

-- 3. 학습할 데이터만 선별하여 머신러닝 모델을 생성
BEGIN
  DBMS_DATA_MINING.DROP_MODEL('MD_ASSOC_ANLYSIS2');
END;
/

CREATE OR REPLACE VIEW VW_ONLINE_RETAIL
 AS 
   SELECT INVOICENO, STOCKCODE
       FROM ONLINE_RETAIL;

BEGIN 
   DBMS_DATA_MINING.CREATE_MODEL(
      MODEL_NAME            => 'MD_ASSOC_ANLYSIS2',
      MINING_FUNCTION       => DBMS_DATA_MINING.ASSOCIATION,
      DATA_TABLE_NAME       => 'VW_ONLINE_RETAIL',
      CASE_ID_COLUMN_NAME   => 'STOCKCODE',
      TARGET_COLUMN_NAME    => NULL,
      SETTINGS_TABLE_NAME   => 'SETTINGS_ASSOCIATION_RULES2');
END;
/

-- 4. 머신러닝 모델을 확인
SELECT MODEL_NAME,
          ALGORITHM,
          MINING_FUNCTION
  FROM ALL_MINING_MODELS
  WHERE MODEL_NAME = 'MD_ASSOC_ANLYSIS2';

-- 5. 머신러닝 모델의 환경 설정을 확인
SELECT SETTING_NAME, SETTING_VALUE
  FROM ALL_MINING_MODEL_SETTINGS
  WHERE MODEL_NAME = 'MD_ASSOC_ANLYSIS2';

--6. 모델이 분석한 상품 간의 연관성을 확인 
SELECT A.ATTRIBUTE_SUBNAME as ANTECEDENT,
       C.ATTRIBUTE_SUBNAME as CONSEQUENT,
       ROUND(RULE_SUPPORT,3) as SUPPORT,
       ROUND(RULE_CONFIDENCE,3) as CONFIDENCE,
       ROUND(RULE_LIFT,3) as LIFT
  FROM  TABLE(DBMS_DATA_MINING.GET_ASSOCIATION_RULES('MD_ASSOC_ANLYSIS2',10)) T,
            TABLE(T.CONSEQUENT) C,
            TABLE(T.ANTECEDENT) A
  ORDER BY SUPPORT DESC, LIFT DESC;


--199. SQL로 머신러닝 구현하기 21 (K-MEANS)

/*
K-means: 비지도 학습 머신러닝
비지도 학습은 지도 학습과는 다르게 데이터에 대한 정답이 없다
지도 학습시에는 정답이 있으므로 머신러닝이 훈련 단계에서 정답을 보면서 공부했으나
비지도 학습은 정답 없이 데이터의 특성만으로 데이터를 분류함

K-means 알고리즘: 유클리드 거리 공식을 이용해 가장 가까운 거리에 있는 데이터로 판단해야 할 데이터를 분류함

여기서는 토마토가 채소와 과일, 단백질 중 어느 클래스에 속하는지 K-means 머신러닝 모델 분류하며 알아봄
*/
-- 1. 머신러닝 모델이 학습할 테이블을 생성
DROP TABLE FRUIT;

CREATE TABLE FRUIT
( F_ID    NUMBER(10),
 F_NAME  VARCHAR2(10),
 SWEET   NUMBER(10),
 CRISPY  NUMBER(10),
 F_CLASS  VARCHAR2(10) );

INSERT INTO FRUIT VALUES( 1, '사과', 10, 9, '과일');
INSERT INTO FRUIT VALUES( 2, '베이컨', 1, 4, '단백질');
INSERT INTO FRUIT VALUES( 3, '바나나', 10, 1, '과일');
INSERT INTO FRUIT VALUES( 4, '당근', 7, 10, '채소');
INSERT INTO FRUIT VALUES( 5, '셀러리', 3, 10, '채소');
INSERT INTO FRUIT VALUES( 6, '치즈', 1, 1, '단백질');
INSERT INTO FRUIT VALUES( 7, '토마토', 6, 7, NULL);
COMMIT;

-- 2. 머신러닝 환경구성 테이블을 생성
DROP TABLE SETTINGS_KM1;

CREATE TABLE SETTINGS_KM1
AS
SELECT *
   FROM TABLE (DBMS_DATA_MINING.GET_DEFAULT_SETTINGS)
   WHERE SETTING_NAME LIKE '%GLM%';

BEGIN

   INSERT INTO SETTINGS_KM1
      VALUES (DBMS_DATA_MINING.ALGO_NAME, 'ALGO_KMEANS');

   INSERT INTO SETTINGS_KM1
      VALUES (DBMS_DATA_MINING.PREP_AUTO, 'ON');

    INSERT INTO SETTINGS_KM1
      VALUES (DBMS_DATA_MINING.CLUS_NUM_CLUSTERS, 3);

   COMMIT;

END;
/

-- 3. 머신러닝 모델을 생성
BEGIN
 DBMS_DATA_MINING.DROP_MODEL('MD_KM_MODEL1');
END;
/

BEGIN 

   DBMS_DATA_MINING.CREATE_MODEL(
      MODEL_NAME            => 'MD_KM_MODEL1',
      MINING_FUNCTION       => DBMS_DATA_MINING.CLUSTERING,
      DATA_TABLE_NAME       => 'FRUIT',
      CASE_ID_COLUMN_NAME   => 'F_ID',
      TARGET_COLUMN_NAME    => NULL,
      SETTINGS_TABLE_NAME   => 'SETTINGS_KM1');
END;
/

DROP TABLE KMEANS_RESULT1;

BEGIN
   DBMS_DATA_MINING.APPLY (MODEL_NAME => 'MD_KM_MODEL1',
                                          DATA_TABLE_NAME => 'FRUIT',
                                          CASE_ID_COLUMN_NAME => 'F_ID',
                                          RESULT_TABLE_NAME => 'KMEANS_RESULT1');
END;
/

-- 4. 머신러닝 모델이 분류한 결과를 확인
SELECT T2.F_NAME,
          T2.F_CLASS,
          T1.CLUSTER_ID,
          T1.PROBABILITY,
          T2.SWEET,
          T2.CRISPY
  FROM (SELECT F_ID, CLUSTER_ID, PROBABILITY
              FROM (SELECT T.*,
                                  MAX (PROBABILITY)  OVER (PARTITION BY F_ID 
                                                                       ORDER BY PROBABILITY DESC) MAXP
                          FROM KMEANS_RESULT1 T)
                          WHERE MAXP = PROBABILITY) T1, FRUIT T2
  WHERE T1.F_ID = T2.F_ID 
  ORDER BY CLUSTER_ID;


 --200. SQL로 머신러닝 구현하기 22 (K-MEANS)
 
 /*
 K-means 머신러닝 알고리즘을 이용하여 미국 시카고 지역의 범죄 발생지의 위도, 경도 데이터를
 이용하여 순찰 지역의 범위를 지정
 */

-- 1. 머신러닝 모델이 학습할 테이블을 생성
DROP TABLE CHICAGO_CRIME; 

CREATE TABLE CHICAGO_CRIME
( C_ID	   NUMBER(10),
 CASE_NUMBER  VARCHAR2(10),
 CRIME_DATE    VARCHAR2(40), 
 PRIMARY_TYPE  VARCHAR2(40),
 DESCRIPTION   VARCHAR2(80),
 LOCATION_DESCRIPTION   VARCHAR2(50),	
 ARREST_YN    VARCHAR2(10),
 DOMESTIC     VARCHAR2(10),
 FBI_CODE      VARCHAR2(10),
 CRIME_YEAR   VARCHAR2(10),	
 LATITUDE      NUMBER(20,10),	
 LONGITUDE    NUMBER(20,10) 
);
--- Chicago_Crimes_2012_to_2017.csv 데이터를 입력

SELECT COUNT(*) FROM CHICAGO_CRIME;
-- 1048575 행

-- 2. 머신러닝 구성 정보 테이블을 생성
DROP TABLE SETTINGS_KM2;

CREATE TABLE SETTINGS_KM2
AS
SELECT *
   FROM TABLE (DBMS_DATA_MINING.GET_DEFAULT_SETTINGS)
   WHERE SETTING_NAME LIKE '%GLM%';

BEGIN

   INSERT INTO SETTINGS_KM2
      VALUES (DBMS_DATA_MINING.ALGO_NAME, 'ALGO_KMEANS');

   INSERT INTO SETTINGS_KM2
      VALUES (DBMS_DATA_MINING.PREP_AUTO, 'ON');

    INSERT INTO SETTINGS_KM2
      VALUES (DBMS_DATA_MINING.CLUS_NUM_CLUSTERS, 14);

   COMMIT;

END;
/

-- 3. 머신러닝 모델을 생성
BEGIN
  DBMS_DATA_MINING.DROP_MODEL('MD_GLM_MODEL2');
END;
/

DROP TABLE KMEANS_RESULT2;

CREATE OR REPLACE VIEW VW_CHICAGO_CRIME
AS 
  SELECT C_ID, LATITUDE, LONGITUDE
    FROM CHICAGO_CRIME;

BEGIN 

   DBMS_DATA_MINING.CREATE_MODEL(
      MODEL_NAME            => 'MD_GLM_MODEL2',
      MINING_FUNCTION       => DBMS_DATA_MINING.CLUSTERING,
      DATA_TABLE_NAME       => 'VW_CHICAGO_CRIME',
      CASE_ID_COLUMN_NAME   => 'C_ID',
      TARGET_COLUMN_NAME    => NULL,
      SETTINGS_TABLE_NAME   => 'SETTINGS_KM2');
END;
/

-- 4. 생성한 머신러닝 모델로 군집화를 진행
BEGIN
   DBMS_DATA_MINING.APPLY (MODEL_NAME => 'MD_GLM_MODEL2',
                                         DATA_TABLE_NAME => 'VW_CHICAGO_CRIME',
                                         CASE_ID_COLUMN_NAME => 'C_ID',
                                         RESULT_TABLE_NAME => 'KMEANS_RESULT2');
END;
/

-- 5. 머신러닝 모델이 군집화한 결과를 확인 
SELECT T1.C_ID,
          T1.CLUSTER_ID,
          T1.PROBABILITY,
          T2.LATITUDE,
          T2.LONGITUDE
  FROM (SELECT C_ID, CLUSTER_ID, PROBABILITY
              FROM (SELECT T.*,
                                  MAX (PROBABILITY) OVER (PARTITION BY C_ID 
                                                                    ORDER BY PROBABILITY DESC) MAXP
                          FROM KMEANS_RESULT2 T)
            WHERE MAXP = PROBABILITY) T1, CHICAGO_CRIME T2
 WHERE T1.C_ID = T2.C_ID ORDER BY CLUSTER_ID;

-- 6. 14개의 군집 번호와 군집번호별 건수를 확인 
SELECT   T1.CLUSTER_ID , COUNT(*)
FROM (SELECT C_ID, CLUSTER_ID, PROBABILITY
            FROM (SELECT T.*,
                                MAX (PROBABILITY) OVER (PARTITION BY C_ID 
                                                                    ORDER BY PROBABILITY DESC) MAXP
                        FROM KMEANS_RESULT2 T)
           WHERE MAXP = PROBABILITY) T1, CHICAGO_CRIME T2
  WHERE T1.C_ID = T2.C_ID 
  GROUP BY T1.CLUSTER_ID;
